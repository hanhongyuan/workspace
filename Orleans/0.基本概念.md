# 基本概念

* 并发带来的问题
    多线程带来的最大的变化就是：我先前保存的变量A，在我想要再次利用它的时候，A是否被其他线程给更改了？数据库中叫脏读，我们拿过来用，“避免脏读”又有个同义词叫做“操作的原子性”。为了解决脏读的问题，有一下几种办法：
    1. 变量A在初始赋值的时候，就规定它不可以被更改，就是不可变，英文叫做immutable，很多函数式语言如F#，scala等都有不可变量。既然量是不可变的。就不会有什么脏读问题了。这真是个好办法，但是不是所有问题都可以通过这个方法解决。
    2. 大家经常使用的，锁（lock）。精巧的设计类，小心的使用这些类，管理各种资源的竞争。为了避免脏读，在C#以及JAVA里，锁是一个可行的办法。但是这样会使得效率变低，更为关键是带来逻辑的复杂性。架锁的程序，可以说是一个“正确但是脆弱”的程序。特别是后期的维护是难以完成的任务。
    3. Orleans采用的办法，设计一个类，保证这个类从“创建”过程到“销毁”过程，以及“中途调用它的方法”的执行过程，这三个“过程”不管何时何地调用，都会在同一个线程中运行。这样的话，我就可以放心大胆的去修改，调用这个类的方法，而不用担心这个指向这个类的变量出现“脏读”的情况。这个某种程度上算是办法一和二的折中。为了说明这个办法，就不得不说Actor模型。

* actor模型框架
    Actor的概念来自于Erlang，在AKKA中，可以认为一个Actor就是一个容器，用以存储状态、行为、Mailbox以及子Actor与Supervisor策略。Actor之间并不直接通信，而是通过Mail来互通有无。
    每个Actor都有且只有一个Mailbox。Mailbox相当于是一个小型的队列，一旦Sender发送消息，就是将该消息入队到Mailbox中。入队的顺序按照消息发送的时间顺序。Mailbox有多种实现，默认为先进先出。但也可以根据优先级考虑出队顺序，实现算法则不相同。
    异步地发送消息是用actor模型编程的重要特性之一。消息并不是直接发送到一个actor，而是发送到一个信箱（mailbox）。这样的设计解耦了actor之间的关系——actor都以自己的步调运行，且发送消息时不会被阻塞。虽然所有actor可以同时运行，但它们都按照信箱接收消息的顺序来依次处理消息，且仅在当前消息处理完成后才会处理下一个消息，因此我们只需要关心发送消息时的并发问题即可。

* 什么是Orleans （奥尔良烤翅）
    Orleans是微软开源的分布式actor模型框架。Orleans 框架可以构建大规模、高并发、分布式应用程序，而不需要学习专业分布式以及并发知识框架。它是由微软研究和设计应用于云计算。
    特点：
    1. 默认的可拓展性，构建复杂的分布式应用程序，可以使您的程序轻易拓展到数百个服务。
    2. 低延时，它可以使你的程序状态保存于内存中，所以你的应用程序可以快速响应请求。
    3. 简化并发，Orleans 允许你使用C#代码构建Actors 之间的异步处理消息。
    Orleans 是一种改进的Actors模式，大量借鉴了Erlang和分布式对象系统中的实现，添加静态类型，消息indirection 和Actors的虚拟化，将它们暴露在一个集成的编程模型中。而Erlang是一个纯粹的函数式语言有其自己特定的虚拟机，Orleans 的编程模型，直接利用.NET 和面向对象的能力，它提供了一个框架，使复杂的分布式应用程序的开发更容易，并使所得到的应用程序的可扩展性更强。不像其他系统如Erlang或Akka 的Actors ， Orleans Grains 的Actors 是虚拟Actors。 他们通过异步消息传递，这大大不同于同步方法调用。
